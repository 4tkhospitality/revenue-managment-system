/**
 * PDF Export Utility v3
 * - Uses modern-screenshot (supports oklab/oklch colors)
 * - Multi-page support
 * - Header/Footer with metadata
 */

import { domToPng } from 'modern-screenshot';
import jsPDF from 'jspdf';

export interface PdfExportOptions {
    orientation: 'portrait' | 'landscape';
    format: 'a4' | 'letter';
    // Header metadata
    hotelName?: string;
    reportTitle?: string;
    asOfDate?: string;
    dateRange?: string;
}

// A4 dimensions in mm
const A4_WIDTH_MM = 210;
const A4_HEIGHT_MM = 297;
const MARGIN_MM = 10;
const HEADER_HEIGHT_MM = 15;
const FOOTER_HEIGHT_MM = 10;

/**
 * Wait for charts/SVGs to render
 */
async function waitForRender(delayMs: number = 500): Promise<void> {
    return new Promise((resolve) => {
        requestAnimationFrame(() => {
            requestAnimationFrame(() => {
                setTimeout(resolve, delayMs);
            });
        });
    });
}

/**
 * Add header to PDF page
 */
function addHeader(
    pdf: jsPDF,
    options: PdfExportOptions,
    pageWidth: number
): void {
    const { hotelName, reportTitle, asOfDate, dateRange } = options;

    pdf.setFontSize(12);
    pdf.setTextColor(45, 74, 140); // Navy blue #2D4A8C

    // Hotel name (left)
    if (hotelName) {
        pdf.text(hotelName, MARGIN_MM, MARGIN_MM + 5);
    }

    // Report title (center)
    if (reportTitle) {
        pdf.setFontSize(14);
        pdf.setFont('helvetica', 'bold');
        const titleWidth = pdf.getTextWidth(reportTitle);
        pdf.text(reportTitle, (pageWidth - titleWidth) / 2, MARGIN_MM + 5);
    }

    // Date info (right)
    pdf.setFontSize(9);
    pdf.setFont('helvetica', 'normal');
    pdf.setTextColor(100, 100, 100);
    const dateText = asOfDate || dateRange || '';
    if (dateText) {
        const dateWidth = pdf.getTextWidth(dateText);
        pdf.text(dateText, pageWidth - MARGIN_MM - dateWidth, MARGIN_MM + 5);
    }

    // Header line
    pdf.setDrawColor(200, 200, 200);
    pdf.line(MARGIN_MM, MARGIN_MM + 8, pageWidth - MARGIN_MM, MARGIN_MM + 8);
}

/**
 * Add footer to PDF page
 */
function addFooter(
    pdf: jsPDF,
    pageNumber: number,
    totalPages: number,
    pageWidth: number,
    pageHeight: number
): void {
    const footerY = pageHeight - MARGIN_MM;

    // Footer line
    pdf.setDrawColor(200, 200, 200);
    pdf.line(MARGIN_MM, footerY - 5, pageWidth - MARGIN_MM, footerY - 5);

    pdf.setFontSize(8);
    pdf.setTextColor(128, 128, 128);

    // Page number (center)
    const pageText = `Trang ${pageNumber} / ${totalPages}`;
    const pageTextWidth = pdf.getTextWidth(pageText);
    pdf.text(pageText, (pageWidth - pageTextWidth) / 2, footerY);

    // Timestamp (left)
    const now = new Date();
    const timestamp = now.toLocaleString('vi-VN', {
        day: '2-digit',
        month: '2-digit',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
    });
    pdf.text(timestamp, MARGIN_MM, footerY);

    // Generated by (right)
    const generatedBy = 'RMS - Revenue Management System';
    const generatedByWidth = pdf.getTextWidth(generatedBy);
    pdf.text(generatedBy, pageWidth - MARGIN_MM - generatedByWidth, footerY);
}

/**
 * Hide elements with pdf-hide class before capture
 */
function hideExportElements(): HTMLElement[] {
    const elements = document.querySelectorAll('.pdf-hide, [data-html2canvas-ignore="true"]');
    const hidden: HTMLElement[] = [];

    elements.forEach((el) => {
        const htmlEl = el as HTMLElement;
        if (htmlEl.style.display !== 'none') {
            hidden.push(htmlEl);
            htmlEl.dataset.originalDisplay = htmlEl.style.display;
            htmlEl.style.display = 'none';
        }
    });

    return hidden;
}

/**
 * Restore hidden elements after capture
 */
function restoreExportElements(elements: HTMLElement[]): void {
    elements.forEach((el) => {
        el.style.display = el.dataset.originalDisplay || '';
        delete el.dataset.originalDisplay;
    });
}

/**
 * Main export function using modern-screenshot
 */
export async function exportToPdf(
    elementId: string,
    filename: string,
    options: PdfExportOptions
): Promise<void> {
    const element = document.getElementById(elementId);

    if (!element) {
        throw new Error(`Không tìm thấy phần tử #${elementId}`);
    }

    // 1. Wait for charts to render
    await waitForRender(500);

    // 2. Hide pdf-hide elements
    const hiddenElements = hideExportElements();

    try {
        // 3. Capture with modern-screenshot (lower scale = lighter file)
        const dataUrl = await domToPng(element, {
            scale: 1.5,  // v3.1: reduced from 2 for lighter PDF
            backgroundColor: '#ffffff',
            style: {
                transform: 'none',
            },
        });

        // 4. Create image from dataUrl
        const img = new Image();
        await new Promise<void>((resolve, reject) => {
            img.onload = () => resolve();
            img.onerror = reject;
            img.src = dataUrl;
        });

        // 5. Setup PDF
        const isLandscape = options.orientation === 'landscape';
        const pageWidth = isLandscape ? A4_HEIGHT_MM : A4_WIDTH_MM;
        const pageHeight = isLandscape ? A4_WIDTH_MM : A4_HEIGHT_MM;

        const pdf = new jsPDF({
            orientation: options.orientation,
            unit: 'mm',
            format: options.format,
        });

        // 6. Calculate dimensions for content area (excluding header/footer)
        const contentWidth = pageWidth - (MARGIN_MM * 2);
        const contentHeight = pageHeight - HEADER_HEIGHT_MM - FOOTER_HEIGHT_MM - MARGIN_MM;
        const contentStartY = MARGIN_MM + HEADER_HEIGHT_MM;

        // 7. Calculate image dimensions
        const imgWidth = contentWidth;
        const imgHeight = (img.height * contentWidth) / img.width;
        const pxPerMm = img.width / contentWidth;

        // 8. Draw full image to source canvas once
        const sourceCanvas = document.createElement('canvas');
        sourceCanvas.width = img.width;
        sourceCanvas.height = img.height;
        const sourceCtx = sourceCanvas.getContext('2d');
        if (!sourceCtx) throw new Error('Could not get canvas context');
        sourceCtx.drawImage(img, 0, 0);

        // 9. Smart page-break: build page slices with intelligent cut points
        const sliceHeightPx = contentHeight * pxPerMm;
        const slices: Array<{ y: number; h: number }> = [];
        let currentY = 0;

        while (currentY < img.height) {
            let sliceH = Math.min(sliceHeightPx, img.height - currentY);

            // If there's more content after this slice, find a smart cut point
            if (currentY + sliceH < img.height) {
                sliceH = findSmartCutPoint(sourceCtx, img.width, currentY, sliceH);
            }

            slices.push({ y: currentY, h: sliceH });
            currentY += sliceH;
        }

        const totalPages = slices.length;

        for (let page = 0; page < totalPages; page++) {
            if (page > 0) {
                pdf.addPage();
            }

            // Add header
            addHeader(pdf, options, pageWidth);

            const slice = slices[page];

            // Create canvas slice for this page
            const pageCanvas = document.createElement('canvas');
            pageCanvas.width = img.width;
            pageCanvas.height = slice.h;

            const ctx = pageCanvas.getContext('2d');
            if (ctx) {
                ctx.drawImage(
                    sourceCanvas,
                    0, slice.y, img.width, slice.h,
                    0, 0, img.width, slice.h
                );

                // v3.1: Use JPEG at 80% quality (much lighter than PNG)
                const pageImgData = pageCanvas.toDataURL('image/jpeg', 0.80);
                const pageImgHeight = (slice.h * contentWidth) / img.width;

                pdf.addImage(
                    pageImgData,
                    'JPEG',
                    MARGIN_MM,
                    contentStartY,
                    imgWidth,
                    pageImgHeight
                );
            }

            // Add footer with page number
            addFooter(pdf, page + 1, totalPages, pageWidth, pageHeight);
        }

        // 10. Save PDF
        pdf.save(`${filename}.pdf`);

    } finally {
        // 11. Restore hidden elements
        restoreExportElements(hiddenElements);
    }
}

/**
 * Find a smart cut point to avoid cutting through text rows.
 * Scans the bottom 15% of the slice for the most "blank" horizontal line
 * (highest average brightness = whitespace between rows).
 */
function findSmartCutPoint(
    ctx: CanvasRenderingContext2D,
    width: number,
    startY: number,
    maxHeight: number
): number {
    // Search zone: bottom 15% of the slice
    const searchStart = Math.floor(maxHeight * 0.85);
    const searchEnd = Math.floor(maxHeight);
    const sampleWidth = Math.min(width, 800); // Sample a strip for speed
    const sampleX = Math.floor((width - sampleWidth) / 2);

    let bestY = maxHeight; // fallback: cut at max height
    let bestBrightness = 0;

    for (let y = searchStart; y < searchEnd; y++) {
        const absoluteY = startY + y;
        const rowData = ctx.getImageData(sampleX, absoluteY, sampleWidth, 1).data;

        // Calculate average brightness of this horizontal line
        let totalBrightness = 0;
        for (let i = 0; i < rowData.length; i += 4) {
            totalBrightness += (rowData[i] + rowData[i + 1] + rowData[i + 2]) / 3;
        }
        const avgBrightness = totalBrightness / (sampleWidth);

        // Higher brightness = more white = better cut point (between rows)
        if (avgBrightness > bestBrightness) {
            bestBrightness = avgBrightness;
            bestY = y;
        }
    }

    // Only use smart cut if we found a clearly bright line (whitespace)
    // Threshold 240+ means it's nearly pure white
    if (bestBrightness > 240) {
        return bestY;
    }

    return maxHeight; // No good cut point found, use default
}

/**
 * Get recommended orientation based on page type
 */
export function getRecommendedOrientation(
    pageType: 'dashboard' | 'analytics' | 'daily'
): 'portrait' | 'landscape' {
    switch (pageType) {
        case 'dashboard':
        case 'analytics':
            return 'landscape'; // Charts are wide
        case 'daily':
            return 'portrait'; // Table is vertical
        default:
            return 'portrait';
    }
}
