generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// Enums
enum JobStatus {
  pending
  processing
  completed
  failed
}

enum ReservationStatus {
  booked
  cancelled
}

enum DecisionAction {
  accept
  override
}

enum ImportType {
  RESERVATION
  CANCELLATION
}

// V01.2: OTA Pricing Module Enums
enum CalcType {
  PROGRESSIVE  // BAR = NET / (1-comm) / Π(1-dᵢ)
  ADDITIVE     // BAR = NET / (1-comm) / (1-Σdᵢ)
}

enum PromotionGroup {
  SEASONAL   // Max 1 per OTA
  ESSENTIAL  // Stackable
  TARGETED   // Max 1 per subcategory
}

// User roles - global and per-hotel
enum UserRole {
  super_admin   // Global system admin
  hotel_admin   // Full access for assigned hotel
  manager       // View + edit + pricing
  viewer        // Read-only
}

// Models

model Hotel {
  hotel_id          String   @id @default(uuid()) @db.Uuid
  name              String
  timezone          String   @default("Asia/Ho_Chi_Minh")
  capacity          Int
  currency          String   @default("VND")
  default_base_rate Decimal? @db.Decimal(12, 2)
  min_rate          Decimal? @db.Decimal(12, 2)
  max_rate          Decimal? @db.Decimal(12, 2)
  fiscal_start_day  Int      @default(1)  // 1-31, first day of fiscal month
  ladder_steps      String?  // JSON array: "[-0.2,-0.1,-0.05,0,0.05,0.1,0.2]"
  company_email     String?  // Optional - for reports/export only
  created_at        DateTime @default(now())

  users                 User[]           // Legacy relation
  hotel_users           HotelUser[]      // New multi-hotel relation
  import_jobs           ImportJob[]
  reservations_raw      ReservationsRaw[]
  daily_otb             DailyOTB[]
  features_daily        FeaturesDaily[]
  demand_forecast       DemandForecast[]
  price_recommendations PriceRecommendations[]
  pricing_decisions     PricingDecision[]
  cancellations_raw     CancellationRaw[]
  
  // V01.2: OTA Pricing Module
  room_types            RoomType[]
  ota_channels          OTAChannel[]
  pricing_setting       PricingSetting?

  @@map("hotels")
}

model User {
  id            String    @id @default(uuid()) @db.Uuid @map("user_id")
  hotel_id      String?   @db.Uuid  // Legacy - kept for migration, remove in V02
  email         String    @unique
  emailVerified DateTime? @map("email_verified")
  name          String?
  phone         String?   // V01.2: Contact phone number
  image         String?   @map("avatar_url")
  role          UserRole  @default(viewer)  // Global role (only super_admin is meaningful)
  is_active     Boolean   @default(true)    // V01: blocked user check
  created_at    DateTime  @default(now())

  // Relations
  hotel             Hotel?            @relation(fields: [hotel_id], references: [hotel_id])
  hotel_users       HotelUser[]       // New: multi-hotel access
  pricing_decisions PricingDecision[]
  accounts          Account[]
  sessions          Session[]

  @@map("users")
}

// V01: Junction table for User-Hotel many-to-many with per-hotel roles
model HotelUser {
  id         String   @id @default(uuid()) @db.Uuid
  user_id    String   @db.Uuid
  hotel_id   String   @db.Uuid
  role       UserRole @default(viewer)  // Per-hotel role: hotel_admin/manager/viewer (NEVER super_admin)
  is_primary Boolean  @default(false)   // Primary hotel for multi-hotel users
  created_at DateTime @default(now())

  user  User  @relation(fields: [user_id], references: [id], onDelete: Cascade)
  hotel Hotel @relation(fields: [hotel_id], references: [hotel_id], onDelete: Cascade)

  @@unique([user_id, hotel_id])
  @@index([hotel_id])
  @@map("hotel_users")
}

// NextAuth.js required models
model Account {
  id                String  @id @default(uuid()) @db.Uuid
  userId            String  @db.Uuid
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}


model Session {
  id           String   @id @default(uuid()) @db.Uuid
  sessionToken String   @unique
  userId       String   @db.Uuid
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}


model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_tokens")
}

model ImportJob {
  job_id        String     @id @default(uuid()) @db.Uuid
  hotel_id      String     @db.Uuid
  import_type   ImportType @default(RESERVATION)
  file_name     String
  file_hash     String?
  status        JobStatus  @default(pending)
  error_summary String?
  total_rows    Int?
  error_log     Json?
  created_at    DateTime   @default(now())
  finished_at   DateTime?

  hotel             Hotel             @relation(fields: [hotel_id], references: [hotel_id])
  reservations_raw  ReservationsRaw[]
  cancellations_raw CancellationRaw[]

  @@map("import_jobs")
}

model ReservationsRaw {
  id              String            @id @default(uuid()) @db.Uuid
  hotel_id        String            @db.Uuid
  job_id          String            @db.Uuid
  reservation_id  String
  
  // === TIME FIELDS (CRITICAL for time-travel OTB) ===
  booking_date    DateTime          @db.Date           // Legacy (for fallback)
  book_time       DateTime?         @db.Timestamptz    // V01.1: Full timestamp for accurate time-travel
  
  arrival_date    DateTime          @db.Date
  departure_date  DateTime          @db.Date
  rooms           Int               // Note: rooms per night
  revenue         Decimal           @db.Decimal
  
  // === STATUS & CANCELLATION FIELDS ===
  status          ReservationStatus                    // 'booked' | 'cancelled' (UI display only)
  cancel_date     DateTime?         @db.Date           // Legacy
  cancel_time     DateTime?         @db.Timestamptz    // V01.1: Full timestamp from cancellation bridge
  cancel_reason   String?                              // V01.1: Optional, for QA & analytics
  cancel_source   String?                              // V01.1: 'guest' | 'hotel' | 'ota' | 'no_show' | 'import'
  
  // === MODIFICATION TRACKING ===
  last_modified_time DateTime?      @db.Timestamptz    // V01.1: For picking latest version
  
  // === NORMALIZED KEYS (for stable matching) ===
  reservation_id_norm String?                          // V01.1: UPPER, TRIM, alphanumeric only
  room_code           String?                          // Room code from reservation
  room_code_norm      String?                          // V01.1: Normalized room code
  
  loaded_at       DateTime          @default(now())

  // === RELATIONS ===
  hotel Hotel     @relation(fields: [hotel_id], references: [hotel_id])
  job   ImportJob @relation(fields: [job_id], references: [job_id])
  
  // === REVERSE RELATION from cancellations ===
  matched_cancellations CancellationRaw[] @relation("MatchedCancellation")

  // === INDEXES (for OTB performance) ===
  @@index([hotel_id, reservation_id_norm, arrival_date, room_code_norm], name: "idx_res_raw_match1")
  @@index([hotel_id, reservation_id_norm, arrival_date], name: "idx_res_raw_match2")
  @@index([hotel_id, book_time, cancel_time, arrival_date, departure_date], name: "idx_res_raw_otb")
  
  // Tracking history and idempotency
  @@unique([hotel_id, reservation_id, job_id], name: "uq_res_job")
  @@map("reservations_raw")
}

model DailyOTB {
  hotel_id    String   @db.Uuid
  as_of_date  DateTime @db.Date
  stay_date   DateTime @db.Date
  rooms_otb   Int
  revenue_otb Decimal  @db.Decimal
  created_at  DateTime @default(now())

  hotel Hotel @relation(fields: [hotel_id], references: [hotel_id])

  @@id([hotel_id, as_of_date, stay_date])
  @@index([hotel_id, as_of_date], name: "idx_otb_as_of")
  @@index([hotel_id, stay_date], name: "idx_otb_stay")
  @@map("daily_otb")
}

model FeaturesDaily {
  hotel_id         String   @db.Uuid
  as_of_date       DateTime @db.Date
  stay_date        DateTime @db.Date
  dow              Int?
  is_weekend       Boolean?
  month            Int?
  pickup_t30       Int?
  pickup_t15       Int?
  pickup_t7        Int?
  pickup_t5        Int?
  pickup_t3        Int?
  pace_vs_ly       Float?
  remaining_supply Int?
  created_at       DateTime @default(now())

  hotel Hotel @relation(fields: [hotel_id], references: [hotel_id])

  @@id([hotel_id, as_of_date, stay_date])
  @@map("features_daily")
}

model DemandForecast {
  hotel_id         String   @db.Uuid
  as_of_date       DateTime @db.Date
  stay_date        DateTime @db.Date
  remaining_demand Int?
  model_version    String?
  created_at       DateTime @default(now())

  hotel Hotel @relation(fields: [hotel_id], references: [hotel_id])

  @@id([hotel_id, as_of_date, stay_date])
  @@map("demand_forecast")
}

model PriceRecommendations {
  hotel_id          String   @db.Uuid
  as_of_date        DateTime @db.Date
  stay_date         DateTime @db.Date
  current_price     Decimal? @db.Decimal
  recommended_price Decimal? @db.Decimal
  expected_revenue  Decimal? @db.Decimal
  uplift_pct        Float?
  explanation       String?
  created_at        DateTime @default(now())

  hotel Hotel @relation(fields: [hotel_id], references: [hotel_id])

  @@id([hotel_id, as_of_date, stay_date])
  @@unique([hotel_id, stay_date, as_of_date], name: "unique_rec")
  @@map("price_recommendations")
}

model PricingDecision {
  decision_id  String         @id @default(uuid()) @db.Uuid
  hotel_id     String         @db.Uuid
  user_id      String         @db.Uuid
  as_of_date   DateTime       @db.Date
  stay_date    DateTime       @db.Date
  action       DecisionAction
  system_price Decimal?       @db.Decimal
  final_price  Decimal?       @db.Decimal
  reason       String?
  decided_at   DateTime       @default(now())

  hotel Hotel @relation(fields: [hotel_id], references: [hotel_id])
  user  User  @relation(fields: [user_id], references: [id])

  @@map("pricing_decisions")
}


// V01 Feature: Cancellation Import + V01.1 Bridge
model CancellationRaw {
  id            String   @id @default(uuid()) @db.Uuid
  hotel_id      String   @db.Uuid
  job_id        String   @db.Uuid

  folio_num     String
  arrival_date  DateTime @db.Date
  cancel_time   DateTime @db.Timestamptz    // V01.1: Must be timestamptz
  as_of_date    DateTime @db.Date           // From {@fmFromDate} in XML header
  nights        Int
  rate_amount   Decimal  @db.Decimal(12, 2)
  total_revenue Decimal  @db.Decimal(12, 2)
  channel       String?                     // sTA_Company from XML
  sale_group    String?                     // GroupName (Sale) from XML
  room_type     String?                     // RoomTypeCode from XML
  room_code     String?                     // Roomcode from XML
  guest_name    String?

  created_at    DateTime @default(now())

  // === NORMALIZED KEYS (V01.1) ===
  folio_num_norm String?                    // UPPER, TRIM, alphanumeric only
  room_code_norm String?                    // Normalized room code

  // === MATCH TRACKING (V01.1: with proper FK relation) ===
  matched_reservation_id String?          @db.Uuid
  matched_reservation    ReservationsRaw? @relation("MatchedCancellation", fields: [matched_reservation_id], references: [id])
  matched_at             DateTime?        @db.Timestamptz
  match_status           String?          // 'matched' | 'unmatched' | 'ambiguous' | 'conflict' | 'dq_issue' | 'unsupported_partial'
  match_notes            String?          // Detailed reason for non-matched status

  // === RELATIONS ===
  hotel Hotel     @relation(fields: [hotel_id], references: [hotel_id])
  job   ImportJob @relation(fields: [job_id], references: [job_id])

  // === UNIQUE CONSTRAINT (V01.1: prevents duplicate imports) ===
  @@unique([hotel_id, folio_num_norm, arrival_date, cancel_time], name: "uq_cancel_event")
  
  @@index([hotel_id, as_of_date], name: "idx_cancel_as_of")
  @@index([hotel_id, cancel_time], name: "idx_cancel_time")
  @@index([hotel_id, arrival_date], name: "idx_cancel_arrival")
  @@index([hotel_id, match_status], name: "idx_cancel_match_status")
  @@map("cancellations_raw")
}


// ============================================================
// V01.2: OTA Pricing Module
// ============================================================

// Room Types with NET base price
model RoomType {
  id          String   @id @default(cuid())
  hotel_id    String   @db.Uuid
  hotel       Hotel    @relation(fields: [hotel_id], references: [hotel_id], onDelete: Cascade)
  
  name        String
  description String?
  net_price   Float    // NET base price (VND)
  
  created_at  DateTime @default(now())
  updated_at  DateTime @updatedAt

  @@index([hotel_id])
  @@unique([hotel_id, name], name: "uq_room_type_name")
  @@map("room_types")
}

// OTA Channel configuration
model OTAChannel {
  id          String   @id @default(cuid())
  hotel_id    String   @db.Uuid
  hotel       Hotel    @relation(fields: [hotel_id], references: [hotel_id], onDelete: Cascade)

  name        String   // Display name: "Agoda"
  code        String   // Code: "agoda", "booking", etc.
  calc_type   CalcType @default(PROGRESSIVE)
  commission  Float    // % (0-100)
  is_active   Boolean  @default(true)

  created_at  DateTime @default(now())
  updated_at  DateTime @updatedAt

  campaigns   CampaignInstance[]

  @@index([hotel_id])
  @@unique([hotel_id, code], name: "uq_ota_channel_code")
  @@map("ota_channels")
}

// Global Promotion Catalog (seed data)
model PromotionCatalog {
  id                       String         @id // e.g. "agoda-seasonal-double-day"
  vendor                   String         // "agoda" | "booking" | etc.
  name                     String
  group_type               PromotionGroup
  sub_category             String?        // For TARGETED: "LOYALTY" | "PLATFORM" | etc.
  default_pct              Float?         // Default discount percentage
  allow_stack              Boolean        @default(true)
  
  // Validation rules
  max_one_in_group         Boolean        @default(false) // true for SEASONAL
  max_one_per_subcategory  Boolean        @default(false) // true for TARGETED

  instances                CampaignInstance[]

  @@index([vendor, group_type])
  @@map("promotion_catalog")
}

// Campaign Instance (promotion applied to hotel/OTA)
model CampaignInstance {
  id             String           @id @default(cuid())
  hotel_id       String           @db.Uuid

  ota_channel_id String
  ota_channel    OTAChannel       @relation(fields: [ota_channel_id], references: [id], onDelete: Cascade)

  promo_id       String
  promo          PromotionCatalog @relation(fields: [promo_id], references: [id])

  discount_pct   Float            // Applied discount %
  is_active      Boolean          @default(true)

  start_date     DateTime?        @db.Date
  end_date       DateTime?        @db.Date

  created_at     DateTime         @default(now())
  updated_at     DateTime         @updatedAt

  @@index([hotel_id, ota_channel_id])
  @@index([promo_id])
  @@map("campaign_instances")
}

// Pricing Settings per hotel
model PricingSetting {
  id               String   @id @default(cuid())
  hotel_id         String   @unique @db.Uuid
  hotel            Hotel    @relation(fields: [hotel_id], references: [hotel_id], onDelete: Cascade)

  currency         String   @default("VND")
  rounding_rule    String   @default("CEIL_1000") // CEIL_1000 | ROUND_100 | NONE
  max_discount_cap Float    @default(80)          // Max total discount %

  created_at       DateTime @default(now())
  updated_at       DateTime @updatedAt

  @@map("pricing_settings")
}
